
from dnf.cli import commands

import platform

from dnf import Plugin, rpm
from dnfpluginscore import logger
from subprocess import run
from os import path, makedirs, environ, unlink, listdir, rmdir, symlink
import re
from rpm2swidtag import repodata
from rpm2swidtag.rpm import get_nevra, get_checksum
from glob import iglob

NAME = "swidtags"

SWIDTAG_DIR_GEN = "var/lib/swidtag"
SWIDTAG_DIR_DOWNLOAD = "usr/lib/swidtag"
SWIDTAGS_D = "etc/swid/swidtags.d"

class swidtagsCommand(commands.Command):
	aliases = [ NAME ]
	summary = "Maintain SWID tags for installed rpms"

	plugin = None

	def __init__(self, cli):
		super(swidtagsCommand, self).__init__(cli)
		# waiting for API: https://bugzilla.redhat.com/show_bug.cgi?id=1678176
		#pylint: disable=protected-access
		for p in self.base._plugins.plugins:
			if p.name == NAME:
				self.plugin = p
				break
		if not self.plugin:
			logger.error("Internal error: cannot find the plugin from command.")
			return

	def configure(self):
		self.cli.demands.available_repos = True
		self.cli.demands.sack_activation = True
		self.cli.demands.resolving = False
		self.cli.demands.root_user = True

	def set_argparser(self, parser):
		parser.add_argument("swidtagscmd", nargs=1, choices=["sync", "regen", "purge"], help="""
sync   for installed rpms, fetch SWID tags from repository metadata or generate them locally
regen  synonym to sync
purge  remove all SWID tags that were locally-generated by the plugin
"""
		)

	def run(self):
		if self.opts.swidtagscmd[0] in ( "purge", "sync", "regen" ):
			self.plugin.purge_generated_dir()
			self.plugin.purge_generated_symlink()
		else:
			print("dnf swidtags [sync | purge]")

		if self.opts.swidtagscmd[0] in ( "sync", "regen" ):
			ts = rpm.transaction.initReadOnlyTransaction(root=self.base.conf.installroot)
			pkgs = []
			for p in ts.dbMatch():
				# Filter out imported GPG keys
				if p["arch"]:
					pkgs.append(p)

			dirs = {}
			for r in self.base.repos.iter_enabled():
				if not hasattr(r, "get_metadata_path"):
					continue
				file = r.get_metadata_path(self.plugin.METADATA_TYPE)
				if not file or file == "":
					continue
				s = repodata.Swidtags(None, file)
				tags = s.tags_for_rpm_packages(pkgs)

				remaining_pkgs = []
				for p in pkgs:
					if p not in tags:
						remaining_pkgs.append(p)
						continue
					found = False
					for t in tags[p]:
						logger.debug("Retrieved SWID tag from repodata for %s: %s", get_nevra(p), t.get_tagid())
						x = t.save_to_directory(self.plugin.dir_downloaded)
						dirs[x[0]] = True
						found = True
					if not found:
						remaining_pkgs.append(p)

				pkgs = remaining_pkgs

			for d in dirs:
				self.plugin.create_swidtags_d_symlink(path.basename(d))

			if len(pkgs) > 0:
				run_ret = self.plugin.run_rpm2swidtag_for([ get_nevra(p) for p in pkgs ])
				if run_ret == 0:
					pkgs_missing = {}
					for p in pkgs:
						pkgs_missing[get_checksum(p)] = p
					for f in iglob(path.join(self.plugin.dir_generated, "*-rpm-*.swidtag")):
						m = re.search(r'-rpm-([0-9a-f]{40}([0-9a-f]{24})?)\.swidtag$', f)
						if m and m.group(1) in pkgs_missing:
							del pkgs_missing[m.group(1)]
					for p in pkgs_missing.values():
						logger.warning("The SWID tag for rpm %s should have been generated but could not be found", get_nevra(p))
				if run_ret == -2:
					logger.warning("The rpm2swidtag_command not configured for the %s plugin.\nSWID tags not generated locally for %d packages.", NAME, len(pkgs))


class swidtags(Plugin):

	name = NAME
	generated_dirname = "rpm2swidtag-generated"

	METADATA_TYPE = "swidtags"

	def __init__(self, base, cli):
		super().__init__(base, cli)
		self.conf = None
		self.install_set = None
		self.remove_set = None
		self.remove_set_checksum = {}
		self.dir_generated = path.join(base.conf.installroot, SWIDTAG_DIR_GEN, self.generated_dirname)
		self.dir_downloaded = path.join(base.conf.installroot, SWIDTAG_DIR_DOWNLOAD)
		self.swidtags_d = path.join(base.conf.installroot, SWIDTAGS_D)
		self.ts = None
		if cli:
			cli.register_command(swidtagsCommand)

	def config(self):
		super(swidtags, self).config()
		self.conf = self.read_config(self.base.conf)
		DEFAULTS = { "main": {
			}
		}
		for s in DEFAULTS:
			if not self.conf.has_section(s):
				try:
					self.conf.addSection(s)
				except AttributeError:
					self.conf.add_section(s)
			for o in DEFAULTS[s]:
				if not self.conf.has_option(s, o):
					try:
						self.conf.setValue(s, o, DEFAULTS[s][o])
					except AttributeError:
						self.conf.set(s, o, DEFAULTS[s][o])

		for repo in self.base.repos.iter_enabled():
			if hasattr(repo, "add_metadata_type_to_download"):
				logger.debug("Will ask for SWID tags download for %s", str(repo.baseurl))
				repo.add_metadata_type_to_download(self.METADATA_TYPE)

	def resolved(self):
		self.install_set = self.base.transaction.install_set
		self.remove_set = self.base.transaction.remove_set
		for p in self.remove_set:
			self.remove_set_checksum[p] = self.get_nevra_checksum(str(p), verbose=False)

	def transaction(self):
		remove_packages = {}
		for p in self.remove_set:
			if p not in self.remove_set_checksum:
				logger.warning("Could not identify checksum for %s, potential SWID tag will not be removed", p)
				continue
			remove_packages[self.remove_set_checksum[p]] = True
		if len(remove_packages) > 0:
			for f in iglob(path.join(self.base.conf.installroot, SWIDTAGS_D, "*", "*-rpm-*.swidtag")):
				m = re.search(r'-rpm-([0-9a-f]{40}([0-9a-f]{24})?)\.swidtag$', f)
				if not m:
					continue
				if m.group(1) in remove_packages:
					self.remove_file(f)

		downloaded_swidtags = {}
		packages_in_repos = { None: [] }
		dirs = {}

		for i in self.install_set:
			try:
				checksum = self.get_nevra_checksum(str(i), verbose=False)
				if not checksum:
					logger.warning("No installed rpm found for package %s, will not sync SWID tag.", str(i) )
					continue

				r = i.repo
				if r not in downloaded_swidtags:
					downloaded_swidtags[r] = None
					if hasattr(r, "get_metadata_path"):
						file = r.get_metadata_path(self.METADATA_TYPE)
						if file and file != "":
							downloaded_swidtags[r] = repodata.Swidtags(None, file)
				if downloaded_swidtags[r]:
					if r not in packages_in_repos:
						packages_in_repos[r] = []
					packages_in_repos[r].append((i, checksum))
					continue
			except KeyError:
				pass
			packages_in_repos[None].append((i, checksum))

		for r in packages_in_repos:
			if not r:
				continue
			tags = downloaded_swidtags[r].tags_for_repo_packages(packages_in_repos[r])
			for p in tags:
				found = False
				for t in tags[p]:
					logger.debug("Retrieved SWID tag from repodata for %s: %s", p[0], t.get_tagid())
					x = t.save_to_directory(self.dir_downloaded)
					dirs[x[0]] = True
					found = True
				if not found:
					packages_in_repos[None].append(p)

		for d in dirs:
			self.create_swidtags_d_symlink(path.basename(d))

		if len(packages_in_repos[None]) > 0:
			p_names = [ str(p[0]) for p in packages_in_repos[None]]
			if self.run_rpm2swidtag_for(p_names) == 0:
				pkgs_missing = {}
				for p in packages_in_repos[None]:
					pkgs_missing[p[1]] = p[0]
				for f in iglob(path.join(self.dir_generated, "*-rpm-*.swidtag")):
					m = re.search(r'-rpm-([0-9a-f]{40}([0-9a-f]{24})?)\.swidtag$', f)
					if m and m.group(1) in pkgs_missing:
						del pkgs_missing[m.group(1)]
				for p in pkgs_missing.values():
					logger.warning("The SWID tag for rpm %s should have been generated but could not be found", str(p))

	def remove_file(self, file):
		try:
			unlink(file)
		except OSError as e:
			logger.warning("Failed to remove [%s]: %s", file, e)

	def purge_generated_dir(self):
		if not path.isdir(self.dir_generated):
			return
		count = 0
		for f in listdir(self.dir_generated):
			try:
				unlink(path.join(self.dir_generated, f))
				count += 1
			except OSError as e:
				logger.warning("Failed to remove [%s]: %s", f, e)
		try:
			rmdir(self.dir_generated)
		except OSError:
			logger.warning("Failed to remove [%s]: %s", self.dir_generated, e)
		if count > 0:
			logger.debug("Removed %d generated files from %s", count, self.dir_generated)

	def purge_generated_symlink(self):
		symlink_path = path.join(self.swidtags_d, self.generated_dirname)
		if not path.islink(symlink_path):
			return
		self.remove_file(symlink_path)

	def create_generated_dir(self):
		if not path.isdir(self.dir_generated):
			makedirs(self.dir_generated)

	def create_download_dir(self, dirname):
		dirname = path.join(self.dir_downloaded, dirname)
		if not path.isdir(dirname):
			makedirs(dirname)

	def create_swidtags_d_symlink(self, basename=None):
		if basename:
			target = path.join(SWIDTAG_DIR_DOWNLOAD, basename)
		else:
			basename = self.generated_dirname
			target = path.join(SWIDTAG_DIR_GEN, basename)
		if not path.isdir(self.swidtags_d):
			makedirs(self.swidtags_d)
		src = path.join(self.swidtags_d, basename)
		if not path.islink(src):
			symlink(path.join("../../..", target), src)

	def run_rpm2swidtag_for(self, pkgs):
		if not pkgs or len(pkgs) < 1:
			return -1
		hostname = platform.uname()[1]
		try:
			rpm2swidtag_command = self.conf.get("main", "rpm2swidtag_command")
		except KeyError:
			return -2
		except Exception as e:
			if e.__class__.__name__ == "NoOptionError":
				return -2
			raise e
		logger.debug("Running %s for %s ...", rpm2swidtag_command, pkgs)
		env = { "_RPM2SWIDTAG_RPMDBPATH": path.join(self.base.conf.installroot, "usr/lib/sysimage/rpm") }
		if not path.isdir(env["_RPM2SWIDTAG_RPMDBPATH"]):
			env["_RPM2SWIDTAG_RPMDBPATH"] = path.join(self.base.conf.installroot, "var/lib/rpm")
		if "PYTHONPATH" in environ:
			env["PYTHONPATH"] = environ["PYTHONPATH"]
		ret = run(rpm2swidtag_command.split() + ["--tag-creator", hostname, "--output-dir", path.join(self.dir_generated, ".")] + pkgs,
			env=env, check=False).returncode
		self.create_generated_dir()
		self.create_swidtags_d_symlink()
		return ret

	def get_nevra_checksum(self, nevra, verbose=True):
		if not self.ts:
			ts = rpm.transaction.initReadOnlyTransaction(root=self.base.conf.installroot)
		rpms = ( ts.dbMatch(2, str(nevra)) )
		if len(rpms) > 1:
			if verbose:
				logger.warning("Multiple rpms %s found installed for package %s.", str(rpms), str(nevra))
			return None
		for r in rpms:
			checksum = get_checksum(r)
			if checksum:
				return checksum
			if verbose:
				logger.warning("No checksum found for rpm %s.", str(nevra))
		return None
